<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker 二 演进历史</title>
      <link href="/2019/08/22/docker-yan-jin-2/"/>
      <url>/2019/08/22/docker-yan-jin-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果说我看得比别人更远些，那是因为我站在巨人的肩膀上。 —— 牛顿</p></blockquote><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>docker 的兴起并不是靠单打独斗，而是背后有着行业内十几年甚至几十年的技术沉淀。它的出现解决了一个一直以来的争论——”软件究竟应该通过什么样的方式进行交互？”，它通过容器镜像，为大家提供了一种全新的组织软件的思路。</p><p>在我看来，容器主要就是一种隔离的执行环境，比虚拟机更轻量。docker容器出现以前，人们使用虚拟机来隔离环境，当然是有代价的，虚拟机拥有独立的系统，分割物理机的各项资源。显然在一台物理机只能启动少量有限的虚拟机。下表为容器和虚拟机做一个简单的对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒</td><td>分钟</td></tr><tr><td>硬盘</td><td>MB</td><td>GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持</td><td>单机上千</td><td>几十个</td></tr></tbody></table><p>一般情况下，容器的优势就一下子凸显出来。</p><p>docker 背后的技术可以追溯到1979年，那时 Unix 系统和 C 语言还在孕育当中，贝尔实验室为了能够在他们的 Unix 系统上“隔离”出一个可以供软件进行构建和测试的环境，他们就创造了 chroot 系统调用，能够使得进行环境被隔离出来。</p><p>后期也出现了类似的技术，比如 FreeBSD 的jail，Oracle Solaris Container等技术，这些技术都是隔离出一个”沙箱“环境，但是这些”沙箱“技术因为”云“的概念还尚未普及，所以他们也只是一门小众技术，局限于特定的领域。</p><p>2004-2007年，Google 发布了一种名为”Process Container“的技术，目的是希望能够拥有虚拟化技术类似，能够给进程提供操作系统级别的资源限制、优先级控制、资源审计能力和进程控制能力，但是又没那么重。2007年，这种技术正式进入了 Linux 内核主干，被更名为 Cgroups（因为内核 container 概念另作他用）</p><p>2008年，融合了 Cgroups 的资源管理能力 和 Linux Namespace 的视图隔离能力，LXC（Linux Container）容器技术出现了。这段时期，云计算也开始正式发展。</p><p>在 docker 出现之前，关于”软件该如何进行交互“，不同阵营有不同观点，也发展了各自的应用领域。</p><p>2013年，docker 项目发布，靠容器化一举统一各大阵营。</p><p>后面就是解决容器该如何编排的问题了。更多详情请查看 <a href="https://mp.weixin.qq.com/s/pIGz-628RANwVMJt7f2vog" target="_blank" rel="external">容器十年</a></p><h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><p>“踩在巨人肩膀上”的 docker 也并没有固步自封，它也一直在更新迭代，框架在不停的升级优化。</p><p>docker 引擎由 Docker CLI， Docker daemon， containerd 和 runc组成，如下图所示：</p><div style="width: 300px; margin: auto"><img src="docker2_1.png" alt="图一"></div><p>docker 早期是依赖 LXC 的，而且只能在 Linux 平台才能使用，通过 LXC 在创建隔离的容器环境。</p><div style="width: 300px; margin: auto"><img src="docker2_3.png" alt="图二"></div><p>缺点也很明显，docker 被局限于 Linux 平台了，而且 LXC 也不是自己独有的技术，受制于第三方组件。对于任何一个有梦想的开发者来说，这都是不能允许出现的，所以他们在0.9版本果断的开发了自己的 libcontainer 技术，替换了 LXC。</p><p>替换了 LXC 之后呢，就又盯上了 Docker daemon，这时它是一个巨大的单体服务，每次更新就必须把所有运行的 container 停掉，这对于线上服务是不可容忍的。于是他们把容器相关的执行逻辑代码全部从 daemon 中移走，就形成了现在的 containerd 程序，用来管理容器，如 start|stop|pause|rm…</p><p>上面我们提到，使用自己的 libcontainer 来替换 LXC后，他们又提供了对 libcontainer 更小、更轻量级的封装 —— runc。它的作用很单纯，就是创建容器。下图就是更详细的结构图。</p><div style="width: 300px; margin: auto"><img src="docker2_2.png" alt="图三"></div><p>当我们在 Docker client中输入命令如：<code>docker container run</code>之后，daemon 进行解析，然后调用 containerd 提供的 API进行命令下发，containerd 收到命令之后，就会准备好镜像环境，通过 runc 来创建容器，创建容器完成之后，runc 就会退出，容器的父进程就转交给 shim （守护进程）。</p><p>daemon 程序被不断的拆分之后，并不是说已经没有什么业务了，其实像镜像管理、网络等功能还是在上面。但是它的更新已经不会再影响到正在运行的容器了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>docker 在不停的发展，指不定哪天技术架构又会有大的改动，但我相信在大家的智慧下，它扔将往好的方向发展，直到被更好的技术取代。</p><p><a href="http://mjammer.com/2019/08/17/docker-yan-jin-2/">接下来</a>，我们将讨论 docker 中的 image 和 container。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 系列文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 一 基础用法</title>
      <link href="/2019/08/17/docker-ji-chu-1/"/>
      <url>/2019/08/17/docker-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>子曾经曰过，docker是个好东西，需要一个系列的文章来总结。因此，本系列将会由浅入深的将我所理解的docker写下来，但我不打算写成入门式的文章，会更偏重理论和工作中遇到的坑。</p></blockquote><p>作为本系列的第一篇文章，让我们以几个例子来看看 docker 的用法。</p><p>第一个例子，把本地编译的二进制文件打包成一个镜像。</p><p>首先我们写一个hello docker程序。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// hello.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello docker"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对应的Dockerfile文件如下：</p><pre class=" language-docker"><code class="language-docker"><span class="token keyword">FROM</span> alpine<span class="token punctuation">:</span>latest<span class="token keyword">COPY</span> hello /usr/local/bin<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"/usr/local/bin/hello"</span><span class="token punctuation">]</span></code></pre><p>在本地（mac 环境）编译，并打入镜像，两步命令如下：</p><p>第一步编译go程序：</p><p>➜ <code>env GOOS=linux GOARCH=386</code> go build hello.go</p><p>第二步打包成镜像：</p><p>➜ docker build -t hello:v1 .</p><p>经过上面两步就打包成一个可用的镜像了，用下面命令运行一下试试看：</p><p>➜ docker run hello:v1</p><p>hello docker</p><p>上面 Dockerfile 文件中，将本地编译的 hello 二进制拷贝到镜像中，并运行。我们用到了下面三个指令：</p><p><code>FROM 指令</code> 这个指令是 Dockerfile 文件第一条必备指令，是指定<code>基础镜像</code>，在上面的例子中，我们从名为”alpine”的基础镜像开始制作镜像。</p><blockquote><p>Alpine 操作系统是一个轻型 Linux 发行版。Alpine Docker 相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5MB 左右（对比 Ubuntu 系列镜像接近 200MB），且拥有非常友好的包管理机制。</p></blockquote><p><code>COPY 指令</code> 从源路径（本地）复制文件到目的路径（容器内）。</p><p><code>CMD 指令</code> 用于指定默认的容器主进程的启动命令的。</p><p>打包镜像时，我们用到 <code>docker build</code> 命令，该命令的格式如下：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>运行时，用到了 <code>docker run</code> 命令，该命令的格式如下：</p><pre><code>docker run [参数] [镜像名 | 镜像 id ] [ 命令 ]</code></pre><p>在编译的时候，不能直接在本机（mac）<code>go build hello.go</code> 一把，需要交叉编译成镜像系统（Alpine）支持的架构，因此在编译的时候，加上了上面的环境变量，这样编译出来的程序才能正常的运行。但是，有时候不想这么麻烦，想在镜像中编译吼不吼？当然吼了，我们只需要更换基础镜像就可以了。</p><pre><code>FROM golang:latestRUN mkdir -p /home/dockerCOPY hello.go /home/dockerWORKDIR /home/dockerRUN go build hello.go &amp;&amp; rm -rf /home/docker/*.goCMD [&quot;/home/docker/hello&quot;]</code></pre><p>上面我们构建了一个<code>镜像</code>，但是什么是 Docker 镜像呢？其实它是一个只读模板，它包含了容器启动所需的所有信息，包括运行程序和配置数据。要运行一个<code>容器</code>，就需要用到一个指定的镜像，而<code>容器</code>就是负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。</p><p><a href="http://mjammer.com/2019/08/17/docker-yan-jin-2/">接下来</a>，我们将讨论 docker 的演进历程，及背后的理论基础。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 系列文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参透“为何”，迎接“任何”</title>
      <link href="/2019/07/11/can-tou-wei-he-ying-jie-ren-he/"/>
      <url>/2019/07/11/can-tou-wei-he-ying-jie-ren-he/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参透‘为何’，才能迎接‘任何’。(He who has a ‘why’ to live for can bear almost any ‘how’) —— 尼采</p></blockquote><p>一周匆忙过后，在周末有了时间思考，内在的空虚就会浮现，当对自己的生活不满意时，就会产生一种忧郁的情绪。这就是所谓的“星期天神经官能症”（Sunday Neurosis）。</p><p>“星期天神经官能症”本质上是“存在的空虚”引起的，而“存在的空虚”所表现的主要现象就是无聊和厌烦。叔本华在《人生的智慧》中写道：“人类注定永远在两极之间游移：不是灾难疾病，就是无聊厌烦。”</p><p>出现“存在的空虚”是因为我们对生命感到全无意义，我们无法找到为了它就值得活下去的某种意义，我们被内在的空虚所萦绕纠缠。但是，生命的意义到底是什么呢？这个终极问题几乎困扰着我们所有人。</p><p>德国作家维克多·弗兰克在他的《活出意义来》一书中给了我们答案。</p><p>生命的意义因人而异，无法找到一个抽象的针对全人类的意义，甚至也无法找到一个人抽象的生命意义。当我们问自己生命的意义到底是什么时，“我们不是在问生命的一般意义为何，而是在问一个人存在的某一时刻中特殊的生命意义为何。一个人不能去寻找抽象的生命意义，每个人都有他自己的特殊天职或使命，而此使命是需要具体去实现的。他的生命无法重复，也不可取代。所以每个人都是独特的，也只有他具有特殊的机遇去完成其独特的天赋使命。”</p><p>“人不应该去问他的生命意义是什么。他必须要认清，‘他’ 才是被询问的人。一言以蔽之，每一个人都被生命询问，而他只有用自己生命才能回答此问题；只有以‘负责’来答复生命。因此，‘能够负责’是人类存在最重要的本质。”</p><p>在遭遇巨大打击时，能坚持下来的往往是那些有想要“负责”的人或事，正是这份“责任”拯救了他们。我们在寻找生命的意义时，需要明白我们自己是为了什么，对什么人或什么事情负责。</p><p>“生命的真谛，必须在世界中找寻，而非在人身上或内在精神中找寻，因为它不是个封闭的体系。”</p><p>生命的意义时刻在改变，我们需要通过发生在自己身上的每件事进行审视，帮它找到所隐藏的意义。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《传习录》之徐爱录</title>
      <link href="/2018/07/20/chuan-xi-lu-zhi-xu-ai-lu/"/>
      <url>/2018/07/20/chuan-xi-lu-zhi-xu-ai-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在徐爱录中，主要记录了王阳明和徐爱就《大学》进行的探讨内容，比较了朱子和王阳明关于大学中部分内容的解释。对“格物”、“知行合一”、“心即理”给出了解释。</p></blockquote><p><em>王阳明的“心学”是在儒学背景下建立的，儒家认为人“性本善”</em></p><p><strong>“在亲民”的解释</strong></p><p>徐向老师请教《大学》中关于“在亲民”的解释，当时的学者都赞同朱熹的解释，朱熹认为，“亲”字通“新”，“在亲民”就是使人民新，而王阳明则解释为亲近，以“君子贤其贤而亲其亲，小人乐其乐而利其利”，“民之所恶恶之，民之所好好之”来说明。我同意王阳明的解释，人是很难被改变的，只能从人自身入手才能改变，当一个人修养自己达到高德性时，更会亲近他人，而他人也自然会受到他潜移默化影响，然后改变自己。</p><p><strong>“格物”的解释</strong></p><p>朱子对于物的解释就是世间的万物，格世间万物，寻求事事物物的道理。而王阳明则认为“心外无物”，这个“物”不是外物，而是自己的“本心”。“格物”就是正心，“正其不正而归于正”，“去其心之不正，以全其本体之正”。</p><p>对“物”他是这么解释的，“身之主宰便是心，心之所发便是意，意之本体便是知，意之所在便是物。”就像事亲，交友，意在何处，何处就是物了。如在事亲，交友等事情上面体察自己的本心，去恶存善。</p><p>有弟子问他为什么不格外物，他的回答大意是“我没有那么多闲时间，我心中就有万物。”</p><p><strong>“知行合一”的解释</strong></p><p>知和行是一体两面的事，是同一件事的两种说法而已，不能分开。“知是行的主意，行是知的功夫；知是行之始，行是知之成”，“未有知而不行者，知而不行，只是未知”。很多人都说，这个事情我知道，只是没有做而已，实际上没有做到其实就是没有真正的知道。</p><p><strong>“心即理”的解释</strong></p><p>人一生下来的天性就是天理，没有一丝邪气浸染，只是在后天成长过程中逐渐夹杂着私欲，我们要做的就是去掉这些私欲，恢复天性。表面上，对父母的孝，对朋友的诚信中都存在着很多理，实际上这些理都在我们自己的内心中，那些只是因为我们怀有对父母的孝心，朋友的诚心。我们所看到的都只是表面功夫，表面功夫易学，难的是有这些心。</p><p>什么样的心才是本心？怎么通过“格物”来达到内心的纯正？努力的着力点在哪里呢？“心即理” 通过学问思辨手段来向心上探求至善的道理，怎么样才能向内求呢？怎么才能知道自己格出来的心就是本体呢？这些问题都太抽象，或许在有一定的生活经验之后才能有深切的体会，我现在唯一能做的就是在做任何事情的时候保持“为善去恶，去掉人伪使内心归于中正”这个念头而已。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传习录 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
