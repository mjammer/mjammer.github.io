<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何写“好”代码</title>
      <link href="/2020/05/22/ru-he-xie-hao-dai-ma/"/>
      <url>/2020/05/22/ru-he-xie-hao-dai-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="代码规范与质量"><a href="#代码规范与质量" class="headerlink" title="代码规范与质量"></a>代码规范与质量</h1><p>本文是关于代码规范和代码质量相关的主题。</p><p>从我们手放在键盘上，敲除第一行代码开始，我们就在写bug的路上一去不返了，我们不是在写bug就是在写bug的路上，当然这些都很正常，除非我们一行代码都不写，那就不会出现bug。</p><p>大家都听过一个名词——技术债务，随着我们写的代码越来越多，技术债务也就随之升高。什么是技术债务呢？通俗来讲就是我们在软件开发的过程中，为了达到当前的目标，写一些只对当前工作内容有效的代码，反正这些代码能够很快的完成工作，再说了“又不是不能用.jpg”。在项目紧急的时候，这么做无可厚非，只要我们在事后能够及时的偿还这些“技术债务”就行了。在事后能够及时偿还“技术债务”，这是理想情况，现实情况更多的是在代码上写上“TODO：这个我们有时间再优化”，众所周知，TODO is NOT TODO。我刚参加工作的时候，领导说的最多的话就是“出来混迟早要还的”，“技术债”也是这样。</p><p>随着项目一个接着一个，似乎每个项目又都是紧急的，“技术债”越积越高，当初承诺要优化的似乎从来没有时间去优化。而我们在项目紧急的时候写的那些“又不是不能用”的代码，好像变得很难理解了。想再在上面写这些勉强可用的代码也变得困难了，结果造成的情况就是“前方产品故障频发，后方开发人员不停地扑火”。</p><p>影响产品质量的因素有很多，这里只讨论代码质量与产品质量的关系，应该怎样去提高代码质量。本文将从以下三个方面来讨论：</p><ul><li>代码风格与规范</li><li>代码重构的方式</li><li>单元测试</li></ul><hr><h3 id="代码风格与规范"><a href="#代码风格与规范" class="headerlink" title="代码风格与规范"></a>代码风格与规范</h3><blockquote><p>首先是为人编写程序，其次才是计算机。</p></blockquote><p>代码风格无非就是那些不写也没关系，不会影响正常功能的东西，譬如命名、注释、函数名等。但是风格良好的代码，可读性就更好，“挨揍”和“挨骂”的可能性就更少，而这些“揍”你和“骂”你的也许就是半年后的自己。</p><h4 id="可读性基本定理"><a href="#可读性基本定理" class="headerlink" title="可读性基本定理"></a>可读性基本定理</h4><p>代码的写法应当使别人（可能是6个月后的自己）理解它所需的时间最小化。要经常地想一想其他人是不是会觉得你的代码容易理解，这需要额外的时间。这样做就需要你打开大脑中从前在编码时可能没有打开的那部分功能。</p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><blockquote><p>一个好的、有意义的命名能够传递足够多的信息，达到替代冗余注释的效果，只通过名字就可以获得大量的信息。</p></blockquote><ul><li><p>名字要有意义</p><p>在为函数或者变量去名字的时候，想一想这个名字需不需要注释来补充说明，如果需要的话，说明取的名字不够好。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> d <span class="token builtin">int32</span> <span class="token comment" spellcheck="true">// 文件创建时间，天</span><span class="token keyword">var</span> daysSinceCreation <span class="token builtin">int32</span></code></pre><p>以上代码中，第一行中的变量<code>d</code>就没有第二行的<code>daysSinceCreation</code>更有意义。</p></li><li><p>避免空泛的名字</p><p>比如<code>tmp</code>,<code>ret</code>,<code>foo</code>,<code>bar</code>等无实际信息的名字。当然，在作用域小，只是临时存储一下中间变量除外。</p><pre class=" language-go"><code class="language-go">tmp <span class="token operator">:=</span> user<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>tmp <span class="token operator">+=</span> <span class="token string">" "</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">Tel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>tmp <span class="token operator">+=</span> <span class="token string">" "</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">Score</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>以上代码，<code>userInfo</code>就比<code>tmp</code>变量可读性更好。</p></li><li><p>使用更专业的名词，更有表现力</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">GetPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token function">DownloadPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>比如有个函数，作用是从网络上获取页面信息，用<code>GetPage</code>容易造成疑惑，不清楚是从数据库还是从网络上获取数据，使用<code>DownloadPage</code>就更专业，更能体现这个函数的功能。</p></li><li><p>用具体的名字代替抽象的名字</p><p>在给变量、函数或者其他元素命名时，要把它描述得更具体而不是更抽象。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ServerCanStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token function">CanListenOnPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 更好</span></code></pre><p>以上代码中<code>CanListenOnPort比</code>ServerCanStart`更具体。</p><p>代码中硬编码的数字也更抽象，用一个便于搜索的变量替代。</p></li><li><p>名字可以带上其他重要信息</p><p>比如，在值为毫秒的变量后面加上<code>_ms</code>，或者在还需要转义的，未处理的变量前面加上<code>raw_</code>。</p></li><li><p>类名和方法名</p><ul><li>类名和对象名使用名词或名词短语，如Customer、AddressParser()</li><li>方法名使用动词或动词短语，如 DeleteUser() 、Save()</li></ul></li></ul><p>名字容易且重要，当你看到一个毫无意义的变量或方法名时，毫不犹豫的改掉，现在的IDE都支持一键改名，几乎毫不费力的改善了代码质量。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>首先引用《Clean Code》中的几句对注释的描述：</p><blockquote><p>“什么也比不上放置良好的注释来得有用。什么也不会比乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更具有破坏力”</p><p>“注释是为了弥补代码的不足”</p><p>“能不能不写注释，从代码上可以很清晰的了解用途”</p><p>好的代码自己本身就是最好的文档。当你打算加注释的时候，问问自己‘我如何才能把我的代码改善到不需增加注释？’重构自己的代码，然后使文档让其更清楚。 — Steve McConnell《代码大全》的作者</p></blockquote><p>从上面大概可以看出，该书的作者对注释持负面态度，作者认为好代码 &gt; 坏代码 + 好注释。</p><p>很多时候我们又不得不写一些注释，仅仅用代码不能很清晰的描述我们的真实意图。那么什么是好的注释？什么样的注释是坏注释呢？又该如何去写呢？</p><p>注释应该是对“意图”进行诠释，好的注释言简意赅，用最少的文字传达了必要的信息，例如以下几种情况的注释：</p><ul><li>这些看起来很怪异的代码为什么这么写</li><li>代码中埋下的“坑”是什么，“这个函数只有我才能调用通，且不能改”</li><li>常量定义，常量的用途，为何取这个值</li><li>总结性的文字描述，告诉别人这段代码的工作机制</li><li>产品/老板要求一定要有这个业务，特殊处理</li></ul><p>而坏注释对代码并没有多少用处，甚至会造成理解上的障碍，如下面这几种情况：</p><ul><li><p>从代码本身就能快速推断的事实写注释</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Account 结构体定义</span><span class="token keyword">type</span> Account <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 设置账户名</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>Account<span class="token punctuation">)</span><span class="token function">SetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li><p>给不好的名字加注释</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Release the handle for this key. This doesn't modify the actual registry.</span><span class="token keyword">func</span> <span class="token function">DeleteRegistry</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">ReleaseRegistryHandle</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span></code></pre><p>与其花额外的精力为不好的名字进行注释，还不如取一个更好的名字。</p></li><li><p>大量的废弃代码注释</p><p>现在都有版本管理，代码不会丢失，在需要的时候看看文件提交历史就能够找回。这些代码果断删除吧，让代码更干净一点。</p></li></ul><p>那我们注释的时候又该如何写呢，下面有些小Tips可以作为参考。</p><ul><li><p>精简注释，让注释描述简洁</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 学生的分数情况，第一个map中的key是学生姓名，第二个map分别是课程名和对应的分数</span>ScoreMap <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int32</span>    <span class="token comment" spellcheck="true">// userName -> [project:score]</span>ScoreMap <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int32</span></code></pre><p>上面两个注释都能说明意图，但是第二个注释显得更简洁，不啰嗦。</p></li><li><p>精确描述函数的行为</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 返回文件的行数</span><span class="token keyword">func</span> <span class="token function">CountLines</span><span class="token punctuation">(</span><span class="token builtin">string</span> fileName<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 统计文件中的 '\n' 换行符个数</span><span class="token keyword">func</span> <span class="token function">CountLines</span><span class="token punctuation">(</span><span class="token builtin">string</span> fileName<span class="token punctuation">)</span></code></pre><p>第一个注释描述的不够清晰，例如空文件算0行还是1行？hello\nworld 算几行？而第二个注释就没有歧义。</p></li><li><p>用适当例子说明特殊情况</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 移除 src 中的 chars </span><span class="token keyword">func</span> <span class="token function">Strip</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> chars <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">string</span><span class="token comment" spellcheck="true">// Example:Strip("abba/a/ba", "ab") -> "/a/"</span><span class="token keyword">func</span> <span class="token function">Strip</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> chars <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">string</span></code></pre><p>第二个在注释中添加恰当的例子，说明了<code>Strip</code>函数的意图。</p></li><li><p>直接申明代码意图</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//add by xx  产品要求一定要给某些高级用户增加xx功能。 时间：2020-04-30</span><span class="token keyword">func</span> <span class="token function">Increase</span><span class="token punctuation">(</span>userId <span class="token builtin">string</span><span class="token punctuation">)</span></code></pre></li></ul><p>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</p><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>逻辑是代码的血肉，清晰的逻辑会让代码更容易理解，有些常用的手段可以稍微简化代码的复杂度。</p><ul><li><p>使用“卫语句（guard clause）”从函数中提前返回</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Save</span><span class="token punctuation">(</span>content <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">bool</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 很多其他判断条件</span>    <span class="token operator">...</span><span class="token punctuation">}</span></code></pre></li><li><p>最小化嵌套</p><pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> userResult <span class="token operator">==</span> SUCCESS<span class="token punctuation">{</span>    <span class="token keyword">if</span> permissionResult <span class="token operator">!=</span> SUCCESS<span class="token punctuation">{</span>        reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"error.."</span><span class="token punctuation">)</span>        reply<span class="token punctuation">.</span>Done        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>userResult<span class="token punctuation">)</span><span class="token punctuation">}</span>reply<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>上面代码 if … else 嵌套对理解并没增加什么困难，但是当在一个复杂函数中时，理解这个嵌套就比较吃力，我们可以提前返回，调整代码顺序，理解起来更容易。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> userResult <span class="token operator">!=</span> SUCCESS<span class="token punctuation">{</span>    reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"error.."</span><span class="token punctuation">)</span>    reply<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> permissionResult <span class="token operator">!=</span> SUCCESS<span class="token punctuation">{</span>    reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"error.."</span><span class="token punctuation">)</span>    reply<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>reply<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>reply<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在循环中出现嵌套我们也可以采取提前返回的方法，只是把<code>return</code>换成<code>break</code>或<code>continue</code>。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> item <span class="token operator">:=</span> <span class="token keyword">range</span> results<span class="token punctuation">{</span>  <span class="token keyword">if</span> item <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do ...</span>    <span class="token keyword">if</span> item<span class="token punctuation">.</span>name <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// do...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>采取条件提前返回，调整代码后：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> item <span class="token operator">:=</span> <span class="token keyword">range</span> results<span class="token punctuation">{</span>  <span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">{</span>    <span class="token keyword">continue</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> item<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">{</span>    <span class="token keyword">continue</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// do ...</span><span class="token punctuation">}</span></code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数应该尽量写的短小，但是该写多小并没有明确的标准，一般来说20-30行最佳。Go语言中，一个函数如果很大，我们可以采用匿名函数将逻辑写的更清晰。</p><p>一个函数只做一件事，不要把不相关的逻辑都堆在一个函数中，把这个函数变成了万能函数。如果发现足够的行数都是在解决不相关的字问题时，果断的把它抽取到独立的函数中。</p><p>在写代码时，可以问问自己下面这些问题，有助于识别不相关代码：</p><ul><li>看到某个函数或者代码块时，问问自己：这段代码的高层次的目标时什么？</li><li>对于每一行代码，问一下：它是直接为了目标而工作吗？这段代码高层次的目标是什么呢？</li></ul></li></ul><h4 id="过度设计"><a href="#过度设计" class="headerlink" title="过度设计"></a>过度设计</h4><p>  程序员倾向于高估有多少功能真的对于他们的项目来讲是必不可少的。很多功能结果没有完成，或者没有用到，也可能只是让程序更复杂。程序员还倾向于低估实现一个功能所要花的工夫。</p><p>  有些用不到的功能并没有想象中那么重要，不一定会在未来用到，我们不需要为这些可能用不到的功能投入宝贵的时间。如一个内部的系统，本身没几个人用，去要求系统的高可用、分布式、微服务和国际化等明显不合理的需求。</p><p>  <strong>以上就是代码规范相关的几点内容，没多少难度却意义重大。</strong></p><hr><h3 id="代码重构的方式"><a href="#代码重构的方式" class="headerlink" title="代码重构的方式"></a>代码重构的方式</h3><p>一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的破窗效应。</p><p>我们的代码也是一样，一段优秀的代码，如果从小到变量命名开始不注意，就会开始“腐烂”，直到自己都忍受不了，最后推倒重来，开始恶性循环。因此，我们需要经常对代码进行重构，不断改善软件设计，使软件更容易理解，保持软件的“生命力”。</p><p><strong>何为重构？</strong></p><p>在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。本质上说，重构就是在代码写好之后改进它的设计，这个改进会让代码更容易理解，更易于修改，而这可能使程序运行得更快，也可能使程序运行得更慢。它融入到整个开发过程，而不是需要专门的时间，需要专门时间来写那是“重写”，而不是“重构”。</p><p><strong>重构时机</strong></p><p>重构是融入到整个开发过程的，上一分钟在写代码，下一分钟可能就在重构。当出现下面一些时机，就可以考虑重构了。</p><ul><li><p>新添加功能</p><p>每次在新添加功能之前，考虑一下是不是把当前代码重构一下，更容易添加这个功能。</p><blockquote><p> 每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改。 </p></blockquote></li><li><p>重复代码——DRY</p><p>当看到重复代码时，毫不犹豫进行重构。</p></li><li><p>过时的知识</p><p>例如当一个语言出现新特性，发现这个特性能够使代码更简洁，更优雅时，可以考虑重构。</p></li><li><p>一个小的重构是否能使代码更容易理解</p></li></ul><p>有个通用的原则就是，保证每次离开你所见到的代码时，比你刚看到时更漂亮。当然也有不需要重构的情况，例如有些运行良好的底层“祖传代码”，已经成功运行N年没出现过bug，很少人动的代码，那就不要重构了，不能保证你重构的代码比现在更好。而有些代码发现重写比重构更容易时，也不要去重构了，直接重写吧。</p><p>在重构之前，一定要确保有良好的测试，在这个前提下用简短又慎重的步骤进行，一次修改一个小点，然后频繁的运行测试用例，保证每次的重构都能通过所有测试，不影响系统正常运行。</p><p><strong>“坏味道”与技巧</strong></p><p>识别出代码中的“坏味道”，然后用一些重构技巧来优化，下面列举一些典型的“坏味道”和常用的重构技巧。</p><ul><li><p>神秘的命名</p><p>正如本文代码风格中关于命名的描述，遇到令人费解的变量、字段或命名时，对它们进行改名操作。现在IDE都支持一键改名操作。</p></li><li><p>重复代码</p><p>重复代码的危害众所周知，修改一处代码的时候还需要兼顾其他代码。</p><p>改变代码的顺序，重组代码，把重复代码提炼成函数。</p></li><li><p>过长的函数</p><p>每当感觉某段代码需要注释来说明的时候，可以把要说明的东西写进一个独立的函数中，并以其用途命名。我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</p></li><li><p>参数列表过长</p><p>引入参数对象，将相关的参数用一个对象封装起来。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Save</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> path<span class="token punctuation">,</span> perm <span class="token builtin">string</span><span class="token punctuation">,</span> length <span class="token builtin">int</span><span class="token punctuation">,</span> flag <span class="token builtin">int</span> <span class="token operator">...</span><span class="token punctuation">)</span></code></pre><p>有些函数有甚至上十个参数，调用的时候容易传参错误，可以定义一个对象，调用时传递该对象即可。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Param <span class="token keyword">struct</span><span class="token punctuation">{</span>  name <span class="token builtin">string</span>  path <span class="token builtin">string</span>   perm <span class="token builtin">string</span>  length <span class="token builtin">int</span>  flag <span class="token builtin">int</span>   <span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Save</span><span class="token punctuation">(</span>data Param<span class="token punctuation">)</span></code></pre></li><li><p>全局变量</p><p>全局变量的危害在于，当不止一处代码会对其进行修改，往往会造成不可预期的结果。</p><p>我们可以采用单例模式或着封装变量，控制全局变量的作用域，对外只提供操作的接口。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> global <span class="token operator">*</span>Asset<span class="token keyword">func</span> <span class="token function">SetAssetName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    global<span class="token punctuation">.</span>Name <span class="token operator">=</span> name<span class="token punctuation">}</span></code></pre></li><li><p>发散式变化</p><p>当我们修改或增加一处功能时，必须同时修改若干个函数，这叫做发散式变化。可以提炼和搬移函数，做到“每次只关心一个上下文”，将相关函数搬到一起。</p></li><li><p>依恋情节</p><p>一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。</p><p>判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起，将那些总是一起变化的东西放在一块。</p></li><li><p>数据泥团</p><p>将分散的变量汇总起来，为数据泥团新建一个类，不要担心只用到了其中几个字段。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> PermData <span class="token keyword">struct</span><span class="token punctuation">{</span>  path <span class="token builtin">string</span>  name <span class="token builtin">string</span>  perm <span class="token builtin">string</span>  <span class="token operator">...</span><span class="token punctuation">}</span></code></pre></li><li><p>过长的消息链（调用链）</p><p>过长的消息链，一旦当其中一个对象发生修改，我们就不得不更改所有地方。</p><pre class=" language-go"><code class="language-go">name <span class="token operator">=</span> <span class="token function">company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>增加一个“中间者”，减少消息链。</p></li><li><p>过大的类</p><p>观察一个大类的使用者，经常能找到如何拆分类的线索。看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。</p></li></ul><hr><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>有人说，看一段代码质量如何，就看代码中的接口多不多。一个接口都没有的代码，很难说是好代码，至少很难测试。在敏捷开发中，有一种TDD方案，在正式写代码之前，先写单元测试，然后再让单元测试通过，</p><p>这种方式能够让代码更优雅，更简洁，当然需要的开发时间也很多。理想是美好的，现实情况是，由于各种原因，不可能严格按照TDD所提倡的方式来进行开发。但是核心代码的单元测试必不可少，只有在有单元测试覆盖的情况下，我们才能放心的进行重构与开发。</p><p>一个好的单元测试要求运行时间短、可以帮忙快速的定位问题，试想一下，如果一个单元测试用例需要运行1s，那么整个项目上千个测试用例耗时难以忍受，我们更不愿意频繁的跑测试。</p><p>有时候，我们会写一些测试代码，来测试功能是否通过，但有时这些不能称之为单元测试，因为往往这些临时写的测试代码，有下面这些特点：</p><ul><li>依赖数据库</li><li>依赖网络通信</li><li>调用文件系统</li><li>需要额外的配置文件</li></ul><p>下面简单介绍一些单元测试中常用到的框架。</p><p><strong>goconvey</strong></p><p>虽然 Golang 自带了单元测试功能和很多其他第三方测试框架，但是 GoConvey 更简洁，更优雅，使用起来更方便。</p><p>我们通过一个案例来介绍如何使用。</p><p>待测试函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">CompareSlice</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> v  <span class="token operator">:=</span> <span class="token keyword">range</span> a<span class="token punctuation">{</span>        <span class="token keyword">if</span> v <span class="token operator">!=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>测试代码：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestCompareSlice</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"TestSliceEqual"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"should be true"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>            b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>            <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">CompareSlice</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldBeTrue<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"should return true a=nil&amp;b=nil"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">CompareSlice</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldBeTrue<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"should return false"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>            b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>            <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">CompareSlice</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldBeFalse<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>最常用的函数就是通过<code>So</code> 进行断言。</p><p>输出：</p><pre class=" language-go"><code class="language-go"><span class="token operator">==</span><span class="token operator">=</span> RUN   TestCompareSlice  TestSliceEqual    should be <span class="token boolean">true</span> ✔    should <span class="token keyword">return</span> <span class="token boolean">true</span> a<span class="token operator">=</span><span class="token boolean">nil</span><span class="token operator">&amp;</span>b<span class="token operator">=</span><span class="token boolean">nil</span> ✔    should <span class="token keyword">return</span> <span class="token boolean">false</span> ✔<span class="token number">3</span> total assertions<span class="token operator">--</span><span class="token operator">-</span> PASS<span class="token punctuation">:</span> <span class="token function">TestCompareSlice</span> <span class="token punctuation">(</span><span class="token number">0.</span>00s<span class="token punctuation">)</span></code></pre><p>测试失败的情况：</p><pre class=" language-go"><code class="language-go"><span class="token operator">==</span><span class="token operator">=</span> RUN   TestCompareSlice2  should be <span class="token boolean">true</span> ✔<span class="token number">1</span> total assertion  should <span class="token keyword">return</span> <span class="token boolean">true</span> a<span class="token operator">=</span><span class="token boolean">nil</span><span class="token operator">&amp;</span>b<span class="token operator">=</span><span class="token boolean">nil</span> ✔<span class="token number">2</span> total assertions  should <span class="token keyword">return</span> <span class="token boolean">false</span> ✘Failures<span class="token punctuation">:</span>  <span class="token operator">*</span> <span class="token operator">/</span>Users<span class="token operator">/</span>jiami<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>awesome<span class="token operator">/</span>example_test<span class="token punctuation">.</span><span class="token keyword">go</span>  Line <span class="token number">44</span><span class="token punctuation">:</span>  Expected<span class="token punctuation">:</span> <span class="token boolean">false</span>  Actual<span class="token punctuation">:</span>   <span class="token boolean">true</span>  goroutine <span class="token number">7</span> <span class="token punctuation">[</span>running<span class="token punctuation">]</span><span class="token punctuation">:</span></code></pre><p>使用时有如下几个要点：</p><p>1、<code>import goconvey</code>包时，前面加”.”号，以减少冗余代码。</p><p>2、测试函数名称以<code>Test</code>开头，参数是<code>*testing.T</code>。</p><p>3、每个测试用例必须用<code>Convey</code>函数包裹起来。</p><p><strong>gomoke</strong></p><p>当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。</p><p>gomoke是官方提供的moke框架，下面将用一个简单的例子来介绍如何使用。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 文件名： db.go</span><span class="token keyword">type</span> DB <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">GetFromDB</span><span class="token punctuation">(</span>db DB<span class="token punctuation">,</span> key <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> value<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> value    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><p>在测试用例中，不能创建真正的数据库连接，这个时候我们就可以<code>moke</code> DB 接口。</p><p>首先生成 moke 对象:</p><pre class=" language-shell"><code class="language-shell">mockgen -source=db.go -destination=db_mock.go -package=main</code></pre><p>此时，就会生成一个名为 <code>db_moke.go</code> 的文件，部分代码如下：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// MockDB is a mock of DB interface</span><span class="token keyword">type</span> MockDB <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ctrl     <span class="token operator">*</span>gomock<span class="token punctuation">.</span>Controller    recorder <span class="token operator">*</span>MockDBMockRecorder<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// MockDBMockRecorder is the mock recorder for MockDB</span><span class="token keyword">type</span> MockDBMockRecorder <span class="token keyword">struct</span> <span class="token punctuation">{</span>    mock <span class="token operator">*</span>MockDB<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// NewMockDB creates a new mock instance</span><span class="token keyword">func</span> <span class="token function">NewMockDB</span><span class="token punctuation">(</span>ctrl <span class="token operator">*</span>gomock<span class="token punctuation">.</span>Controller<span class="token punctuation">)</span> <span class="token operator">*</span>MockDB <span class="token punctuation">{</span>    mock <span class="token operator">:=</span> <span class="token operator">&amp;</span>MockDB<span class="token punctuation">{</span>ctrl<span class="token punctuation">:</span> ctrl<span class="token punctuation">}</span>    mock<span class="token punctuation">.</span>recorder <span class="token operator">=</span> <span class="token operator">&amp;</span>MockDBMockRecorder<span class="token punctuation">{</span>mock<span class="token punctuation">}</span>    <span class="token keyword">return</span> mock<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// EXPECT returns an object that allows the caller to indicate expected use</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MockDB<span class="token punctuation">)</span> <span class="token function">EXPECT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>MockDBMockRecorder <span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token punctuation">.</span>recorder<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Get mocks base method</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MockDB<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> m<span class="token punctuation">.</span>ctrl<span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"Get"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>    ret0<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ret<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>    ret1<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ret<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret0<span class="token punctuation">,</span> ret1<span class="token punctuation">}</span><span class="token operator">...</span></code></pre><p>接下来，在我们的测试用例中就可以使用 <code>MockDB</code> 来模拟DB操作了，测试代码如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestGetFromDB</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"test mock"</span><span class="token punctuation">,</span>t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctrl <span class="token operator">:=</span> gomock<span class="token punctuation">.</span><span class="token function">NewController</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">defer</span> ctrl<span class="token punctuation">.</span><span class="token function">Finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        m <span class="token operator">:=</span> <span class="token function">NewMockDB</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">EXPECT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>gomock<span class="token punctuation">.</span><span class="token function">Eq</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Return</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"not exist"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">GetFromDB</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        m<span class="token punctuation">.</span><span class="token function">EXPECT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>gomock<span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">DoAndReturn</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token string">"test"</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"not exist"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AnyTimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">GetFromDB</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">GetFromDB</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token string">"test1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我们可以使用<code>EXCEPT()</code>函数来“打桩”——给定明确的参数和返回值、检测调用次数、调用顺序，动态设置返回值等。</p><p><strong>gomonkey</strong></p><p>这是国人写的一个很方便的打桩框架，接口友好，功能强大，支持下面一些特性：</p><ul><li>支持为一个函数打一个桩</li><li>支持为一个成员方法打一个桩</li><li>支持为一个全局变量打一个桩</li><li>支持为一个函数变量打一个桩</li><li>支持为一个函数打一个特定的桩序列</li><li>支持为一个成员方法打一个特定的桩序列</li><li>支持为一个函数变量打一个特定的桩序列</li></ul><p>下面就“支持为一个函数打一个桩”、“支持为一个成员方法打一个桩”、“支持为一个全局变量打一个桩”来举例说明如何使用，具体功能有兴趣可自行搜索。</p><p><strong>为一个函数打一个桩</strong></p><p>需要用到下面一个接口：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ApplyFunc</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Patches<span class="token punctuation">)</span> <span class="token function">ApplyFunc</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches</code></pre><p>ApplyFunc 第一个参数是函数名，第二个参数是桩函数。测试完成后，patches 对象通过 Reset 成员方法删除所有测试桩。<br>假设我们有一个用来比较大小的函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">CompareInt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> a <span class="token operator">==</span> b<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">></span> b<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们需要为这个函数“打桩”，让它在被调用时返回指定的结果，用法如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestCompareInt</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"CompareInt"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        patch <span class="token operator">:=</span> <span class="token function">ApplyFunc</span><span class="token punctuation">(</span>CompareInt<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token boolean">_</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">defer</span> patch<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span><span class="token function">CompareInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>设置完桩函数之后，我们再次调用，无论参数是什么，它都会返回 0 值。</p><p>这个也可以给标准库中的函数进行“打桩”，比如 <code>strconv.FormatInt</code>函数：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestPackage</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        patch <span class="token operator">:=</span> <span class="token function">ApplyFunc</span><span class="token punctuation">(</span>strconv<span class="token punctuation">.</span>FormatInt<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token boolean">_</span> <span class="token builtin">int64</span><span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token builtin">string</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"test_package"</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">defer</span> patch<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span>strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token string">"test_package"</span><span class="token punctuation">)</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"test_2"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">So</span><span class="token punctuation">(</span>strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token string">"test_package"</span><span class="token punctuation">)</span>            patch<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">So</span><span class="token punctuation">(</span>strconv<span class="token punctuation">.</span><span class="token function">FormatInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>设置完桩函数后，<code>strconv.FormatInt</code>就不是原先的函数了，它只会返回”test_package”。</p><p><strong>为一个成员方法打一个桩</strong></p><p>需要用到下面这个接口：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ApplyMethod</span><span class="token punctuation">(</span>target reflect<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> methodName <span class="token builtin">string</span><span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Patches<span class="token punctuation">)</span> <span class="token function">ApplyMethod</span><span class="token punctuation">(</span>target reflect<span class="token punctuation">.</span>Type<span class="token punctuation">,</span> methodName <span class="token builtin">string</span><span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches</code></pre><p>例如，我们有个 <code>RedisCli</code> 类，用来表示 redis 连接，其中有个 Get 方法：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> RedisCli <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>RedisCli<span class="token punctuation">)</span><span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span></code></pre><p>在单元测试中，不能真正的连接 redis，为了测试代码，我们除了可以 moke 外，还可以为 <code>Get</code> 方法打桩，让它暂时返回指定结果。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TestClass</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"test class"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> redisCli <span class="token operator">*</span>RedisCli        patch <span class="token operator">:=</span> <span class="token function">ApplyMethod</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>redisCli<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Get"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token boolean">_</span> <span class="token operator">*</span>RedisCli<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"test_redis_get"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">defer</span> patch<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        redisCli <span class="token operator">=</span> <span class="token operator">&amp;</span>RedisCli<span class="token punctuation">{</span><span class="token punctuation">}</span>        rsp<span class="token punctuation">,</span> err <span class="token operator">:=</span> redisCli<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> ShouldBeNil<span class="token punctuation">)</span>        <span class="token function">So</span><span class="token punctuation">(</span>rsp<span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token string">"test_redis_get"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>注意：如果打桩目标为内联的函数或成员方法，请在测试时通过命令行参数 <code>-gcflags=-l</code> 关闭内联优化。</p><p><strong>为一个全局变量打一个桩</strong></p><p>需要用到下面一个接口：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ApplyGlobalVar</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches<span class="token keyword">func</span> <span class="token punctuation">(</span>this <span class="token operator">*</span>Patches<span class="token punctuation">)</span> <span class="token function">ApplyGlobalVar</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> double <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">*</span>Patches</code></pre><p>使用示例如下：</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 全局变量插桩</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">func</span> <span class="token function">TestApplyGlobalVar</span><span class="token punctuation">(</span>t <span class="token operator">*</span>testing<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"test global var"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"change"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            patch <span class="token operator">:=</span> <span class="token function">ApplyGlobalVar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>num<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>            <span class="token keyword">defer</span> patch<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">So</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">Convey</span><span class="token punctuation">(</span><span class="token string">"recover"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">So</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> ShouldEqual<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文内容只是作为一个简单的介绍，很多内容被舍弃掉了，如果觉得太浅显或太长不看，那么只需要在编码时记得时刻问自己下面两个问题：</p><ul><li>如果这样写代码，半年后的我会不会骂现在的自己？</li><li>这块代码怎样写才方便测试？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 三 image 和 container</title>
      <link href="/2019/09/03/docker-image-3/"/>
      <url>/2019/09/03/docker-image-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>image 之于 container 就好似灵魂之于肉体，没有 image 的 container 就像”无米之炊，无源之水“。</p></blockquote><p>docker image 是静态的内容，container 是动态的内容。</p><p>学习 image，需要牢记下面几个要点：</p><p>1、明白 image 是由层级组成了，层是静态的。</p><p>2、通过 ufs 机制，将多个层映射到同一目录，将层级概念隐藏起来，对使用者透明。</p><p>3、container 运行时，会在 image 上添加一个读写层，通过 copy-on-write 机制将需要更新的文件从 Docker 镜像层中拷贝至读写层，然后对读写层中的副本进行操作。对使用者来说，它只能看到最上层的文件。</p><p>下面这篇文章写的很详细，所以在此毋庸赘述。</p><p><a href="http://blog.daocloud.io/principle-of-docker-image/" target="_blank" rel="external">深入分析 Docker 镜像原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 系列文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 二 演进历史</title>
      <link href="/2019/08/22/docker-yan-jin-2/"/>
      <url>/2019/08/22/docker-yan-jin-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果说我看得比别人更远些，那是因为我站在巨人的肩膀上。 —— 牛顿</p></blockquote><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>docker 的兴起并不是靠单打独斗，而是背后有着行业内十几年甚至几十年的技术沉淀。它的出现解决了一个一直以来的争论——”软件究竟应该通过什么样的方式进行交互？”，它通过容器镜像，为大家提供了一种全新的组织软件的思路。</p><p>在我看来，容器主要就是一种隔离的执行环境，比虚拟机更轻量。docker容器出现以前，人们使用虚拟机来隔离环境，当然是有代价的，虚拟机拥有独立的系统，分割物理机的各项资源。显然在一台物理机只能启动少量有限的虚拟机。下表为容器和虚拟机做一个简单的对比：</p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒</td><td>分钟</td></tr><tr><td>硬盘</td><td>MB</td><td>GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持</td><td>单机上千</td><td>几十个</td></tr></tbody></table><p>一般情况下，容器的优势就一下子凸显出来。</p><p>docker 背后的技术可以追溯到1979年，那时 Unix 系统和 C 语言还在孕育当中，贝尔实验室为了能够在他们的 Unix 系统上“隔离”出一个可以供软件进行构建和测试的环境，他们就创造了 chroot 系统调用，能够使得进行环境被隔离出来。</p><p>后期也出现了类似的技术，比如 FreeBSD 的jail，Oracle Solaris Container等技术，这些技术都是隔离出一个”沙箱“环境，但是这些”沙箱“技术因为”云“的概念还尚未普及，所以他们也只是一门小众技术，局限于特定的领域。</p><p>2004-2007年，Google 发布了一种名为”Process Container“的技术，目的是希望能够拥有虚拟化技术类似，能够给进程提供操作系统级别的资源限制、优先级控制、资源审计能力和进程控制能力，但是又没那么重。2007年，这种技术正式进入了 Linux 内核主干，被更名为 Cgroups（因为内核 container 概念另作他用）</p><p>2008年，融合了 Cgroups 的资源管理能力 和 Linux Namespace 的视图隔离能力，LXC（Linux Container）容器技术出现了。这段时期，云计算也开始正式发展。</p><p>在 docker 出现之前，关于”软件该如何进行交互“，不同阵营有不同观点，也发展了各自的应用领域。</p><p>2013年，docker 项目发布，靠容器化一举统一各大阵营。</p><p>后面就是解决容器该如何编排的问题了。更多详情请查看 <a href="https://mp.weixin.qq.com/s/pIGz-628RANwVMJt7f2vog" target="_blank" rel="external">容器十年</a></p><h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><p>“踩在巨人肩膀上”的 docker 也并没有固步自封，它也一直在更新迭代，框架在不停的升级优化。</p><p>docker 引擎由 Docker CLI， Docker daemon， containerd 和 runc组成，如下图所示：</p><div style="width: 300px; margin: auto"><img src="docker2_1.png" alt="图一"></div><p>docker 早期是依赖 LXC 的，而且只能在 Linux 平台才能使用，通过 LXC 在创建隔离的容器环境。</p><div style="width: 300px; margin: auto"><img src="docker2_3.png" alt="图二"></div><p>缺点也很明显，docker 被局限于 Linux 平台了，而且 LXC 也不是自己独有的技术，受制于第三方组件。对于任何一个有梦想的开发者来说，这都是不能允许出现的，所以他们在0.9版本果断的开发了自己的 libcontainer 技术，替换了 LXC。</p><p>替换了 LXC 之后呢，就又盯上了 Docker daemon，这时它是一个巨大的单体服务，每次更新就必须把所有运行的 container 停掉，这对于线上服务是不可容忍的。于是他们把容器相关的执行逻辑代码全部从 daemon 中移走，就形成了现在的 containerd 程序，用来管理容器，如 start|stop|pause|rm…</p><p>上面我们提到，使用自己的 libcontainer 来替换 LXC后，他们又提供了对 libcontainer 更小、更轻量级的封装 —— runc。它的作用很单纯，就是创建容器。下图就是更详细的结构图。</p><div style="width: 300px; margin: auto"><img src="docker2_2.png" alt="图三"></div><p>当我们在 Docker client中输入命令如：<code>docker container run</code>之后，daemon 进行解析，然后调用 containerd 提供的 API进行命令下发，containerd 收到命令之后，就会准备好镜像环境，通过 runc 来创建容器，创建容器完成之后，runc 就会退出，容器的父进程就转交给 shim （守护进程）。</p><p>daemon 程序被不断的拆分之后，并不是说已经没有什么业务了，其实像镜像管理、网络等功能还是在上面。但是它的更新已经不会再影响到正在运行的容器了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>docker 在不停的发展，指不定哪天技术架构又会有大的改动，但我相信在大家的智慧下，它仍将往好的方向发展，直到被更好的技术取代。</p><p><a href="http://mjammer.com/2019/09/03/docker-image-3/">接下来</a>，我们将讨论 docker 中的 image 和 container。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 系列文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 一 基础用法</title>
      <link href="/2019/08/17/docker-ji-chu-1/"/>
      <url>/2019/08/17/docker-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>子曾经曰过，docker是个好东西，需要一个系列的文章来总结。因此，本系列将会由浅入深的将我所理解的docker写下来，但我不打算写成入门式的文章，会更偏重理论和工作中遇到的坑。</p></blockquote><p>作为本系列的第一篇文章，让我们以几个例子来看看 docker 的用法。</p><p>第一个例子，把本地编译的二进制文件打包成一个镜像。</p><p>首先我们写一个hello docker程序。</p><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// hello.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello docker"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对应的Dockerfile文件如下：</p><pre class=" language-docker"><code class="language-docker"><span class="token keyword">FROM</span> alpine<span class="token punctuation">:</span>latest<span class="token keyword">COPY</span> hello /usr/local/bin<span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"/usr/local/bin/hello"</span><span class="token punctuation">]</span></code></pre><p>在本地（mac 环境）编译，并打入镜像，两步命令如下：</p><p>第一步编译go程序：</p><p>➜ <code>env GOOS=linux GOARCH=386</code> go build hello.go</p><p>第二步打包成镜像：</p><p>➜ docker build -t hello:v1 .</p><p>经过上面两步就打包成一个可用的镜像了，用下面命令运行一下试试看：</p><p>➜ docker run hello:v1</p><p>hello docker</p><p>上面 Dockerfile 文件中，将本地编译的 hello 二进制拷贝到镜像中，并运行。我们用到了下面三个指令：</p><p><code>FROM 指令</code> 这个指令是 Dockerfile 文件第一条必备指令，是指定<code>基础镜像</code>，在上面的例子中，我们从名为”alpine”的基础镜像开始制作镜像。</p><blockquote><p>Alpine 操作系统是一个轻型 Linux 发行版。Alpine Docker 相比于其他 Docker 镜像，它的容量非常小，仅仅只有 5MB 左右（对比 Ubuntu 系列镜像接近 200MB），且拥有非常友好的包管理机制。</p></blockquote><p><code>COPY 指令</code> 从源路径（本地）复制文件到目的路径（容器内）。</p><p><code>CMD 指令</code> 用于指定默认的容器主进程的启动命令的。</p><p>打包镜像时，我们用到 <code>docker build</code> 命令，该命令的格式如下：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>运行时，用到了 <code>docker run</code> 命令，该命令的格式如下：</p><pre><code>docker run [参数] [镜像名 | 镜像 id ] [ 命令 ]</code></pre><p>在编译的时候，不能直接在本机（mac）<code>go build hello.go</code> 一把，需要交叉编译成镜像系统（Alpine）支持的架构，因此在编译的时候，加上了上面的环境变量，这样编译出来的程序才能正常的运行。但是，有时候不想这么麻烦，想在镜像中编译吼不吼？当然吼了，我们只需要更换基础镜像就可以了。</p><pre><code>FROM golang:latestRUN mkdir -p /home/dockerCOPY hello.go /home/dockerWORKDIR /home/dockerRUN go build hello.go &amp;&amp; rm -rf /home/docker/*.goCMD [&quot;/home/docker/hello&quot;]</code></pre><p>上面我们构建了一个<code>镜像</code>，但是什么是 Docker 镜像呢？其实它是一个只读模板，它包含了容器启动所需的所有信息，包括运行程序和配置数据。要运行一个<code>容器</code>，就需要用到一个指定的镜像，而<code>容器</code>就是负责应用程序的运行，包括操作系统、用户添加的文件以及元数据。</p><p><a href="http://mjammer.com/2019/08/17/docker-yan-jin-2/">接下来</a>，我们将讨论 docker 的演进历程，及背后的理论基础。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker 系列文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参透“为何”，迎接“任何”</title>
      <link href="/2019/07/11/can-tou-wei-he-ying-jie-ren-he/"/>
      <url>/2019/07/11/can-tou-wei-he-ying-jie-ren-he/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参透‘为何’，才能迎接‘任何’。(He who has a ‘why’ to live for can bear almost any ‘how’) —— 尼采</p></blockquote><p>一周匆忙过后，在周末有了时间思考，内在的空虚就会浮现，当对自己的生活不满意时，就会产生一种忧郁的情绪。这就是所谓的“星期天神经官能症”（Sunday Neurosis）。</p><p>“星期天神经官能症”本质上是“存在的空虚”引起的，而“存在的空虚”所表现的主要现象就是无聊和厌烦。叔本华在《人生的智慧》中写道：“人类注定永远在两极之间游移：不是灾难疾病，就是无聊厌烦。”</p><p>出现“存在的空虚”是因为我们对生命感到全无意义，我们无法找到为了它就值得活下去的某种意义，我们被内在的空虚所萦绕纠缠。但是，生命的意义到底是什么呢？这个终极问题几乎困扰着我们所有人。</p><p>德国作家维克多·弗兰克在他的《活出意义来》一书中给了我们答案。</p><p>生命的意义因人而异，无法找到一个抽象的针对全人类的意义，甚至也无法找到一个人抽象的生命意义。当我们问自己生命的意义到底是什么时，“我们不是在问生命的一般意义为何，而是在问一个人存在的某一时刻中特殊的生命意义为何。一个人不能去寻找抽象的生命意义，每个人都有他自己的特殊天职或使命，而此使命是需要具体去实现的。他的生命无法重复，也不可取代。所以每个人都是独特的，也只有他具有特殊的机遇去完成其独特的天赋使命。”</p><p>“人不应该去问他的生命意义是什么。他必须要认清，‘他’ 才是被询问的人。一言以蔽之，每一个人都被生命询问，而他只有用自己生命才能回答此问题；只有以‘负责’来答复生命。因此，‘能够负责’是人类存在最重要的本质。”</p><p>在遭遇巨大打击时，能坚持下来的往往是那些有想要“负责”的人或事，正是这份“责任”拯救了他们。我们在寻找生命的意义时，需要明白我们自己是为了什么，对什么人或什么事情负责。</p><p>“生命的真谛，必须在世界中找寻，而非在人身上或内在精神中找寻，因为它不是个封闭的体系。”</p><p>生命的意义时刻在改变，我们需要通过发生在自己身上的每件事进行审视，帮它找到所隐藏的意义。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《传习录》之徐爱录</title>
      <link href="/2018/07/20/chuan-xi-lu-zhi-xu-ai-lu/"/>
      <url>/2018/07/20/chuan-xi-lu-zhi-xu-ai-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在徐爱录中，主要记录了王阳明和徐爱就《大学》进行的探讨内容，比较了朱子和王阳明关于大学中部分内容的解释。对“格物”、“知行合一”、“心即理”给出了解释。</p></blockquote><p><em>王阳明的“心学”是在儒学背景下建立的，儒家认为人“性本善”</em></p><p><strong>“在亲民”的解释</strong></p><p>徐向老师请教《大学》中关于“在亲民”的解释，当时的学者都赞同朱熹的解释，朱熹认为，“亲”字通“新”，“在亲民”就是使人民新，而王阳明则解释为亲近，以“君子贤其贤而亲其亲，小人乐其乐而利其利”，“民之所恶恶之，民之所好好之”来说明。我同意王阳明的解释，人是很难被改变的，只能从人自身入手才能改变，当一个人修养自己达到高德性时，更会亲近他人，而他人也自然会受到他潜移默化影响，然后改变自己。</p><p><strong>“格物”的解释</strong></p><p>朱子对于物的解释就是世间的万物，格世间万物，寻求事事物物的道理。而王阳明则认为“心外无物”，这个“物”不是外物，而是自己的“本心”。“格物”就是正心，“正其不正而归于正”，“去其心之不正，以全其本体之正”。</p><p>对“物”他是这么解释的，“身之主宰便是心，心之所发便是意，意之本体便是知，意之所在便是物。”就像事亲，交友，意在何处，何处就是物了。如在事亲，交友等事情上面体察自己的本心，去恶存善。</p><p>有弟子问他为什么不格外物，他的回答大意是“我没有那么多闲时间，我心中就有万物。”</p><p><strong>“知行合一”的解释</strong></p><p>知和行是一体两面的事，是同一件事的两种说法而已，不能分开。“知是行的主意，行是知的功夫；知是行之始，行是知之成”，“未有知而不行者，知而不行，只是未知”。很多人都说，这个事情我知道，只是没有做而已，实际上没有做到其实就是没有真正的知道。</p><p><strong>“心即理”的解释</strong></p><p>人一生下来的天性就是天理，没有一丝邪气浸染，只是在后天成长过程中逐渐夹杂着私欲，我们要做的就是去掉这些私欲，恢复天性。表面上，对父母的孝，对朋友的诚信中都存在着很多理，实际上这些理都在我们自己的内心中，那些只是因为我们怀有对父母的孝心，朋友的诚心。我们所看到的都只是表面功夫，表面功夫易学，难的是有这些心。</p><p>什么样的心才是本心？怎么通过“格物”来达到内心的纯正？努力的着力点在哪里呢？“心即理” 通过学问思辨手段来向心上探求至善的道理，怎么样才能向内求呢？怎么才能知道自己格出来的心就是本体呢？这些问题都太抽象，或许在有一定的生活经验之后才能有深切的体会，我现在唯一能做的就是在做任何事情的时候保持“为善去恶，去掉人伪使内心归于中正”这个念头而已。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传习录 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
